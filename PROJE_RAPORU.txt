================================================================================
SQL INJECTION GÜVENLİK AÇIĞI ANALİZİ VE DÜZELTME RAPORU
================================================================================

Ders: Vulnerability and Security
Proje Tipi: OPTION 1 - Mini Web Application Vulnerability Project
Öğrenci: Ege Koca
Tarih: 2025

================================================================================
1. ÖZET (EXECUTIVE SUMMARY)
================================================================================

Bu proje, web uygulamalarında en yaygın görülen güvenlik açıklarından biri olan 
SQL Injection (SQLi) zafiyetini incelemek, exploit etmek ve düzeltmek amacıyla 
geliştirilmiştir. Flask framework'ü kullanılarak bir restoran menü yönetim sistemi 
oluşturulmuş, kasıtlı olarak SQL Injection açıkları içeren bir versiyon ve bu 
açıkları düzelten güvenli bir versiyon geliştirilmiştir.

ANA BULGULAR:
- 3 farklı noktada SQL Injection açığı tespit edildi
- Tüm açıklar başarıyla exploit edildi
- Parametreli sorgular kullanılarak tüm açıklar düzeltildi
- Düzeltmeler %100 etkili oldu

================================================================================
2. PROJE HEDEFLERİ
================================================================================

Bu projenin temel hedefleri şunlardır:

1. Gerçekçi Web Uygulaması Geliştirme
   - Restoran menü yönetim sistemi
   - Kullanıcı girişi, menü görüntüleme, arama, admin paneli
   - SQLite veritabanı ile çalışan dinamik içerik

2. Güvenlik Açığı Tespiti
   - SQL Injection açıklarını belirleme
   - Açıkların neden oluştuğunu analiz etme
   - Kod seviyesinde açık lokasyonlarını tespit etme

3. Açıkları Exploit Etme
   - Kontrollü ortamda saldırı senaryoları oluşturma
   - Farklı SQL Injection tekniklerini test etme
   - Saldırıların etkisini gözlemleme

4. Açıkları Düzeltme
   - Güvenli kodlama teknikleri uygulama
   - Parametreli sorgular kullanma
   - Düzeltmelerin etkinliğini doğrulama

================================================================================
3. UYGULAMA MİMARİSİ
================================================================================

3.1 Teknoloji Yığını

- Backend Framework: Flask 3.0.0
- Veritabanı: SQLite3
- Programlama Dili: Python 3.9+
- Template Engine: Jinja2
- Ortam: Localhost (127.0.0.1:5000 ve 5001)

3.2 Veritabanı Yapısı

Uygulama aşağıdaki tablolardan oluşmaktadır:

1. users - Kullanıcı bilgileri (id, username, password, role, full_name)
2. menu_items - Menü öğeleri (id, name, category, price, description, image_url)
3. customers - Müşteri bilgileri (id, user_id, name, email, phone, address)
4. orders - Siparişler (id, customer_id, item_id, quantity, total_price, order_date, status)
5. employees - Çalışan bilgileri (id, user_id, name, position, salary, email)

3.3 Uygulama Versiyonları

- Güvensiz Versiyon: app.py (Port 5000) - SQL Injection açıkları içerir
- Güvenli Versiyon: app_secure.py (Port 5001) - Parametreli sorgular kullanır

================================================================================
4. TESPİT EDİLEN SQL INJECTION AÇIKLARI
================================================================================

4.1 AÇIK #1: LOGIN FONKSİYONUNDA SQL INJECTION
--------------------------------------------------------------------------------

4.1.1 Açığın Konumu

Dosya: app.py
Fonksiyon: login()
Satırlar: 156-168

4.1.2 Güvensiz Kod

@app.route('/login', methods=['POST'])
def login():
    """Login handler with SQL Injection vulnerability"""
    username = request.form.get('username', '').strip()
    password = request.form.get('password', '').strip() or ''
    
    if not username:
        flash('Lütfen kullanıcı adı girin', 'error')
        return redirect(url_for('index'))
    
    # VULNERABLE CODE: Direct string interpolation (SQL Injection vulnerability)
    # This is intentionally insecure for educational purposes
    query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
    
    # Log the query to terminal
    log_query(f"username={username}, password={password}", query)
    
    try:
        conn = sqlite3.connect(DB_FILE)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Execute the vulnerable query
        cursor.execute(query)
        user = cursor.fetchone()

Kritik Satır: Satır 168
query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"

4.1.3 Açığın Nedeni

- Kullanıcı girdisi doğrudan string interpolation (f-string) ile SQL sorgusuna ekleniyor
- Hiçbir input validation veya sanitization yapılmıyor
- Parametreli sorgular kullanılmıyor
- Kullanıcı girdisi SQL kodu olarak yorumlanabiliyor

4.1.4 Saldırı Senaryosu

Payload:
Kullanıcı Adı: ' OR '1'='1' --
Şifre: (boş bırakılır)

Oluşturulan SQL Sorgusu:
SELECT * FROM users WHERE username = '' OR '1'='1' --' AND password = ''

Açıklama:
- ' - Orijinal string'i kapatır
- OR '1'='1' - Her zaman TRUE olan bir koşul ekler
- -- - Sorgunun geri kalanını yorum satırı yapar (şifre kontrolü atlanır)

Sonuç: Şifre olmadan ilk kullanıcıya (admin) giriş yapılır.

[EKRAN RESMİ 1] Login sayfasında SQL Injection payload'ının girilmesi
Dosya adı: 01_login_sql_injection_payload.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 2] Terminal'de görüntülenen manipüle edilmiş SQL sorgusu
Dosya adı: 02_terminal_manipulated_query.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 3] Başarılı giriş sonrası menü sayfası (yetkisiz erişim)
Dosya adı: 03_unauthorized_access_success.png
Konum: Bu bölümün altına eklenecek

--------------------------------------------------------------------------------

4.2 AÇIK #2: MENÜ ARAMA FONKSİYONUNDA SQL INJECTION
--------------------------------------------------------------------------------

4.2.1 Açığın Konumu

Dosya: app.py
Fonksiyon: search()
Satırlar: 247-257

4.2.2 Güvensiz Kod

@app.route('/search', methods=['POST'])
def search():
    """Menu search with SQL Injection vulnerability"""
    if not session.get('logged_in'):
        flash('Lütfen önce giriş yapın', 'error')
        return redirect(url_for('index'))
    
    search_term = request.form.get('search', '').strip()
    
    if not search_term:
        flash('Lütfen bir arama terimi girin', 'error')
        return redirect(url_for('menu'))
    
    # VULNERABLE CODE: Direct string interpolation
    query = f"SELECT * FROM menu_items WHERE name LIKE '%{search_term}%' OR description LIKE '%{search_term}%'"

Kritik Satır: Satır 257
query = f"SELECT * FROM menu_items WHERE name LIKE '%{search_term}%' OR description LIKE '%{search_term}%'"

4.2.3 Açığın Nedeni

- Arama terimi doğrudan LIKE sorgusuna ekleniyor
- UNION SELECT ile diğer tablolardan veri çekilebiliyor
- Veritabanı yapısı ifşa edilebiliyor

4.2.4 Saldırı Senaryosu

Payload 1: Tüm Menüyü Görüntüleme
Arama: ' OR '1'='1

Oluşturulan SQL Sorgusu:
SELECT * FROM menu_items WHERE name LIKE '%' OR '1'='1%' OR description LIKE '%' OR '1'='1%'

Payload 2: Müşteri Bilgilerini Çekme
Arama: ' UNION SELECT * FROM customers --

Oluşturulan SQL Sorgusu:
SELECT * FROM menu_items WHERE name LIKE '%' UNION SELECT * FROM customers --%' OR description LIKE '%' UNION SELECT * FROM customers --%'

Sonuç: Müşteri tablosundaki tüm hassas bilgiler (isim, email, telefon, adres) görüntülenir.

[EKRAN RESMİ 4] Menü arama sayfasında UNION SELECT payload'ının girilmesi
Dosya adı: 04_menu_search_union_payload.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 5] UNION SELECT ile çekilen müşteri bilgileri
Dosya adı: 05_customer_data_exposed.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 6] Terminal'de görüntülenen UNION SELECT sorgusu
Dosya adı: 06_terminal_union_query.png
Konum: Bu bölümün altına eklenecek

--------------------------------------------------------------------------------

4.3 AÇIK #3: ADMIN PANELİ KULLANICI EKLEME FONKSİYONUNDA SQL INJECTION
--------------------------------------------------------------------------------

4.3.1 Açığın Konumu

Dosya: app.py
Fonksiyon: add_user()
Satırlar: 320-340

4.3.2 Güvensiz Kod

@app.route('/admin/add_user', methods=['POST'])
def add_user():
    """Add user with SQL Injection vulnerability (admin only)"""
    if not session.get('logged_in'):
        flash('Lütfen önce giriş yapın', 'error')
        return redirect(url_for('index'))
    
    if session.get('role') != 'admin':
        flash('Bu işlem için admin yetkisi gereklidir', 'error')
        return redirect(url_for('show_database'))
    
    username = request.form.get('username', '').strip()
    password = request.form.get('password', '').strip()
    full_name = request.form.get('full_name', '').strip()
    role = request.form.get('role', 'customer').strip()
    
    if not username or not password:
        flash('Kullanıcı adı ve şifre gereklidir', 'error')
        return redirect(url_for('show_database'))
    
    # VULNERABLE CODE: Direct string interpolation (SQL Injection vulnerability)
    # This is intentionally insecure for educational purposes
    query = f"INSERT INTO users (username, password, role, full_name) VALUES ('{username}', '{password}', '{role}', '{full_name}')"

Kritik Satır: Satır 340
query = f"INSERT INTO users (username, password, role, full_name) VALUES ('{username}', '{password}', '{role}', '{full_name}')"

4.3.3 Açığın Nedeni

- Tüm form alanları doğrudan INSERT sorgusuna ekleniyor
- Kullanıcı adı kontrolü bypass edilebiliyor
- İstenen role sahip kullanıcı oluşturulabiliyor
- Veritabanı bütünlüğü bozulabiliyor

4.3.4 Saldırı Senaryosu

Payload:
Kullanıcı Adı: test', 'hacked', 'admin', 'Hacker') --
Şifre: anything
Tam İsim: anything
Rol: customer

Oluşturulan SQL Sorgusu:
INSERT INTO users (username, password, role, full_name) VALUES ('test', 'hacked', 'admin', 'Hacker') --', 'anything', 'customer', 'anything')

Açıklama:
- test' - İlk değeri kapatır
- , 'hacked', 'admin', 'Hacker') - Yeni değerler ekler
- -- - Sorgunun geri kalanını yorum satırı yapar

Sonuç: Admin yetkisine sahip yeni bir kullanıcı oluşturulur.

[EKRAN RESMİ 7] Admin panelinde SQL Injection payload'ının girilmesi
Dosya adı: 07_admin_panel_sql_injection.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 8] Oluşturulan admin kullanıcısının veritabanında görüntülenmesi
Dosya adı: 08_admin_user_created.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 9] Terminal'de görüntülenen manipüle edilmiş INSERT sorgusu
Dosya adı: 09_terminal_insert_query.png
Konum: Bu bölümün altına eklenecek

================================================================================
5. DÜZELTME STRATEJİSİ
================================================================================

5.1 Çözüm: Parametreli Sorgular (Prepared Statements)

Tüm SQL Injection açıkları, parametreli sorgular kullanılarak düzeltilmiştir. 
Parametreli sorgular, SQL kodunu kullanıcı verisinden ayırarak, kullanıcı 
girdisinin SQL kodu olarak yorumlanmasını engeller.

5.2 DÜZELTME #1: LOGIN FONKSİYONU
--------------------------------------------------------------------------------

5.2.1 Güvenli Kod

Dosya: app_secure.py
Fonksiyon: login()
Satırlar: 156-170

@app.route('/login', methods=['POST'])
def login():
    """Login handler with SQL Injection protection"""
    username = request.form.get('username', '').strip()
    password = request.form.get('password', '').strip()
    
    if not username:
        flash('Lütfen kullanıcı adı girin', 'error')
        return redirect(url_for('index'))
    
    # SECURE CODE: Parameterized query
    query_template = "SELECT * FROM users WHERE username = ? AND password = ?"
    
    log_query(f"username={username}, password={password}", 
              f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}' (parameterized)")
    
    try:
        conn = sqlite3.connect(DB_FILE)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute(query_template, (username, password))
        user = cursor.fetchone()

Kritik Değişiklik: Satır 163-164
query_template = "SELECT * FROM users WHERE username = ? AND password = ?"
cursor.execute(query_template, (username, password))

5.2.2 Nasıl Çalışıyor?

1. Query Template: SQL sorgu yapısı ayrı olarak tanımlanır
2. Parametre Yer Tutucuları: ? işaretleri kullanıcı verisinin nereye ekleneceğini işaretler
3. Güvenli Çalıştırma: Kullanıcı verisi parametre olarak geçirilir, sorgu string'ine eklenmez
4. Otomatik Escaping: Veritabanı sürücüsü özel karakterleri otomatik olarak escape eder

5.2.3 Test Sonuçları

Payload Denemesi:
Kullanıcı Adı: ' OR '1'='1' --
Şifre: (boş)

Oluşturulan Sorgu:
SELECT * FROM users WHERE username = ? AND password = ?
Parametreler: (' OR '1'='1' --, '')

Sonuç: Veritabanı, kullanıcı adı tam olarak ' OR '1'='1' -- olan bir kullanıcı arar. 
Böyle bir kullanıcı olmadığı için giriş başarısız olur.

[EKRAN RESMİ 10] Güvenli versiyonda aynı payload ile giriş denemesi
Dosya adı: 10_secure_version_login_attempt.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 11] Güvenli versiyonda başarısız giriş mesajı
Dosya adı: 11_secure_login_blocked.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 12] Terminal'de parametreli sorgu logları
Dosya adı: 12_terminal_parameterized_query.png
Konum: Bu bölümün altına eklenecek

--------------------------------------------------------------------------------

5.3 DÜZELTME #2: MENÜ ARAMA FONKSİYONU
--------------------------------------------------------------------------------

5.3.1 Güvenli Kod

Dosya: app_secure.py
Fonksiyon: search()
Satırlar: 247-260

@app.route('/search', methods=['POST'])
def search():
    """Menu search with SQL Injection protection"""
    if not session.get('logged_in'):
        flash('Lütfen önce giriş yapın', 'error')
        return redirect(url_for('index'))
    
    search_term = request.form.get('search', '').strip()
    
    if not search_term:
        flash('Lütfen bir arama terimi girin', 'error')
        return redirect(url_for('menu'))
    
    # SECURE CODE: Parameterized query
    query_template = "SELECT * FROM menu_items WHERE name LIKE ? OR description LIKE ?"
    search_pattern = f'%{search_term}%'
    
    log_query(search_term, 
              f"SELECT * FROM menu_items WHERE name LIKE '%{search_term}%' OR description LIKE '%{search_term}%' (parameterized)")
    
    try:
        conn = sqlite3.connect(DB_FILE)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute(query_template, (search_pattern, search_pattern))

Kritik Değişiklik: Satır 257-260
query_template = "SELECT * FROM menu_items WHERE name LIKE ? OR description LIKE ?"
search_pattern = f'%{search_term}%'
cursor.execute(query_template, (search_pattern, search_pattern))

5.3.2 Test Sonuçları

Payload Denemesi:
Arama: ' UNION SELECT * FROM customers --

Oluşturulan Sorgu:
SELECT * FROM menu_items WHERE name LIKE ? OR description LIKE ?
Parametreler: ('%' UNION SELECT * FROM customers --%', '%' UNION SELECT * FROM customers --%')

Sonuç: UNION SELECT payload'ı literal string olarak işlenir, SQL kodu olarak çalıştırılmaz. 
Sadece menü öğeleri aranır.

[EKRAN RESMİ 13] Güvenli versiyonda UNION SELECT denemesi
Dosya adı: 13_secure_union_attempt.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 14] Güvenli versiyonda saldırının engellendiği mesajı
Dosya adı: 14_secure_union_blocked.png
Konum: Bu bölümün altına eklenecek

--------------------------------------------------------------------------------

5.4 DÜZELTME #3: ADMIN PANELİ KULLANICI EKLEME FONKSİYONU
--------------------------------------------------------------------------------

5.4.1 Güvenli Kod

Dosya: app_secure.py
Fonksiyon: add_user()
Satırlar: 320-345

@app.route('/admin/add_user', methods=['POST'])
def add_user():
    """Add user with SQL Injection protection (admin only)"""
    if not session.get('logged_in'):
        flash('Lütfen önce giriş yapın', 'error')
        return redirect(url_for('index'))
    
    if session.get('role') != 'admin':
        flash('Bu işlem için admin yetkisi gereklidir', 'error')
        return redirect(url_for('show_database'))
    
    username = request.form.get('username', '').strip()
    password = request.form.get('password', '').strip()
    full_name = request.form.get('full_name', '').strip()
    role = request.form.get('role', 'customer').strip()
    
    if not username or not password:
        flash('Kullanıcı adı ve şifre gereklidir', 'error')
        return redirect(url_for('show_database'))
    
    # SECURE CODE: Parameterized query
    query_template = "INSERT INTO users (username, password, role, full_name) VALUES (?, ?, ?, ?)"
    
    log_query(f"username={username}, password={password}, role={role}, full_name={full_name}", 
              f"INSERT INTO users (username, password, role, full_name) VALUES ('{username}', '{password}', '{role}', '{full_name}') (parameterized)")
    
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        
        cursor.execute(query_template, (username, password, role, full_name))
        conn.commit()

Kritik Değişiklik: Satır 338-345
query_template = "INSERT INTO users (username, password, role, full_name) VALUES (?, ?, ?, ?)"
cursor.execute(query_template, (username, password, role, full_name))

5.4.2 Test Sonuçları

Payload Denemesi:
Kullanıcı Adı: test', 'hacked', 'admin', 'Hacker') --

Oluşturulan Sorgu:
INSERT INTO users (username, password, role, full_name) VALUES (?, ?, ?, ?)
Parametreler: ("test', 'hacked', 'admin', 'Hacker') --", "anything", "customer", "anything")

Sonuç: Payload literal string olarak işlenir. Kullanıcı adı tam olarak 
test', 'hacked', 'admin', 'Hacker') -- olarak kaydedilir. SQL kodu olarak çalıştırılmaz.

[EKRAN RESMİ 15] Güvenli versiyonda admin panelinde SQL Injection denemesi
Dosya adı: 15_secure_admin_panel_attempt.png
Konum: Bu bölümün altına eklenecek

[EKRAN RESMİ 16] Güvenli versiyonda payload'ın literal string olarak kaydedilmesi
Dosya adı: 16_secure_payload_as_string.png
Konum: Bu bölümün altına eklenecek

================================================================================
6. KARŞILAŞTIRMALI ANALİZ
================================================================================

6.1 Güvensiz vs Güvenli Kod Karşılaştırması

Özellik                    | Güvensiz Versiyon                          | Güvenli Versiyon
---------------------------|-------------------------------------------|-------------------------------------------
Login Sorgusu              | f"SELECT * FROM users WHERE username = '{username}'..." | "SELECT * FROM users WHERE username = ?..." + parametreler
Arama Sorgusu              | f"SELECT * FROM menu_items WHERE name LIKE '%{search_term}%'..." | "SELECT * FROM menu_items WHERE name LIKE ?..." + parametreler
INSERT Sorgusu             | f"INSERT INTO users ... VALUES ('{username}', ...)" | "INSERT INTO users ... VALUES (?, ...)" + parametreler
SQL Injection              | Exploit edilebilir                         | Engellendi
Input Validation            | Yok                                        | Parametreli sorgular
Güvenlik Seviyesi          | Kritik                                     | Güvenli

6.2 Test Sonuçları Özeti

Test Senaryosu                          | Güvensiz Versiyon        | Güvenli Versiyon
----------------------------------------|--------------------------|------------------
Normal giriş (admin/admin123)          | Başarılı                 | Başarılı
SQL Injection login (' OR '1'='1' --)   | Yetkisiz erişim          | Engellendi
Normal arama (Pizza)                   | Çalışıyor                | Çalışıyor
UNION SELECT arama                     | Veri ifşası              | Engellendi
Normal kullanıcı ekleme                 | Çalışıyor                | Çalışıyor
SQL Injection kullanıcı ekleme         | Veritabanı manipülasyonu | Engellendi

[EKRAN RESMİ 17] Güvensiz ve güvenli versiyonların yan yana karşılaştırması
Dosya adı: 17_comparison_side_by_side.png
Konum: Bu bölümün altına eklenecek

================================================================================
7. ETKİ ANALİZİ
================================================================================

7.1 Güvenlik Açığının Etkisi

Confidentiality (Gizlilik): YÜKSEK
- Kullanıcı hesaplarına yetkisiz erişim
- Hassas müşteri bilgilerinin ifşası (email, telefon, adres)
- Çalışan bilgilerinin ifşası (maaş, pozisyon)

Integrity (Bütünlük): YÜKSEK
- Veritabanı manipülasyonu
- Yetkisiz kullanıcı oluşturma
- Admin yetkisi ele geçirme

Availability (Erişilebilirlik): ORTA
- Hizmet kesintisi yaratmaz
- Ancak veri bütünlüğü bozulabilir

Genel Önem Derecesi: KRİTİK

7.2 Gerçek Dünya Senaryoları

Bu açıklar gerçek dünyada şu sonuçlara yol açabilir:

1. Kimlik Hırsızlığı: Müşteri bilgilerinin çalınması
2. Finansal Zarar: Yetkisiz siparişler, fiyat manipülasyonu
3. Yasal Sorunlar: KVKK ihlalleri, veri sızıntısı
4. İtibar Kaybı: Güven kaybı, müşteri kaybı
5. İş Sürekliliği: Sistem güvenilirliğinin kaybı

================================================================================
8. ÖNERİLEN İYİLEŞTİRMELER
================================================================================

8.1 Ek Güvenlik Önlemleri

1. Input Validation
   - Kullanıcı girdilerinin format kontrolü
   - Minimum/maksimum uzunluk kontrolü
   - Özel karakter filtreleme

2. Rate Limiting
   - Brute force saldırılarını önleme
   - IP bazlı erişim kısıtlaması

3. Password Hashing
   - Şifrelerin hash'lenmesi (bcrypt, argon2)
   - Salt kullanımı

4. Session Management
   - Güvenli session token'ları
   - Session timeout

5. Logging ve Monitoring
   - Şüpheli aktivitelerin loglanması
   - Anomali tespiti

6. Least Privilege Principle
   - Veritabanı kullanıcılarının minimum yetki ile çalışması
   - Read-only kullanıcılar için ayrı hesaplar

================================================================================
9. SONUÇ VE ÖĞRENİLEN DERSLER
================================================================================

9.1 Proje Sonuçları

Bu proje ile:

1. 3 farklı SQL Injection açığı tespit edildi
2. Tüm açıklar başarıyla exploit edildi
3. Parametreli sorgular kullanılarak tüm açıklar düzeltildi
4. Düzeltmeler %100 etkili oldu
5. Normal uygulama işlevselliği korundu

9.2 Öğrenilen Dersler

1. Asla güvenme, doğrula (Never Trust, Always Validate)
   - Kullanıcı girdilerine asla güvenilmemeli
   - Her zaman input validation yapılmalı

2. Parametreli sorgular zorunludur
   - SQL Injection'ı önlemenin en etkili yolu
   - Tüm veritabanı işlemlerinde kullanılmalı

3. Güvenlik by design
   - Güvenlik sonradan eklenemez, baştan tasarlanmalı
   - Secure coding practices uygulanmalı

4. Sürekli test ve denetim
   - Düzenli güvenlik testleri yapılmalı
   - Penetrasyon testleri önemli

5. Eğitim ve farkındalık
   - Geliştiricilerin güvenlik konusunda eğitilmesi
   - OWASP Top 10 gibi kaynakların takip edilmesi

9.3 Proje Başarı Kriterleri

Kriter                              | Durum
------------------------------------|----------
Gerçekçi web uygulaması geliştirme | Başarılı
Güvenlik açığı tespiti              | 3 açık tespit edildi
Açıkları exploit etme               | Tüm açıklar exploit edildi
Açıkları düzeltme                   | Parametreli sorgular ile düzeltildi
Düzeltmelerin doğrulanması          | %100 etkili

================================================================================
10. REFERANSLAR
================================================================================

1. OWASP Top 10 (2021) - A03:2021 – Injection
   https://owasp.org/Top10/

2. OWASP SQL Injection
   https://owasp.org/www-community/attacks/SQL_Injection

3. CWE-89: SQL Injection
   https://cwe.mitre.org/data/definitions/89.html

4. Flask Security Best Practices
   https://flask.palletsprojects.com/en/latest/security/

5. SQLite Parameterized Queries
   https://docs.python.org/3/library/sqlite3.html

================================================================================
11. EKLER
================================================================================

11.1 Proje Dosya Yapısı

SecurityProje/
├── app.py                      # Güvensiz versiyon (SQL Injection açıkları)
├── app_secure.py              # Güvenli versiyon (Parametreli sorgular)
├── init_db.py                 # Veritabanı başlatma scripti
├── requirements.txt            # Python bağımlılıkları
├── README.md                   # Proje dokümantasyonu
├── VULNERABILITY_REPORT.md    # Detaylı güvenlik açığı raporu
├── EXPLOIT_GUIDE.md           # Exploit rehberi
├── FIX_VERIFICATION.md        # Düzeltme doğrulama raporu
├── DEMO_SCRIPT.md             # Demo scripti
├── PROJE_RAPORU.md            # Markdown format rapor
├── PROJE_RAPORU.txt           # Bu rapor (TXT format)
├── restaurant.db              # Güvensiz versiyon veritabanı
├── restaurant_secure.db       # Güvenli versiyon veritabanı
└── templates/
    ├── login.html             # Güvensiz versiyon login
    ├── login_secure.html      # Güvenli versiyon login
    ├── menu.html              # Menü sayfası
    ├── menu_secure.html       # Güvenli menü sayfası
    ├── database.html          # Admin paneli (güvensiz)
    ├── database_secure.html   # Admin paneli (güvenli)
    ├── search_results.html    # Arama sonuçları
    └── search_results_secure.html # Güvenli arama sonuçları

11.2 Ekran Resimleri Listesi

Aşağıdaki ekran resimleri raporun ilgili bölümlerine eklenmelidir:

1. 01_login_sql_injection_payload.png - Bölüm 4.1.4
2. 02_terminal_manipulated_query.png - Bölüm 4.1.4
3. 03_unauthorized_access_success.png - Bölüm 4.1.4
4. 04_menu_search_union_payload.png - Bölüm 4.2.4
5. 05_customer_data_exposed.png - Bölüm 4.2.4
6. 06_terminal_union_query.png - Bölüm 4.2.4
7. 07_admin_panel_sql_injection.png - Bölüm 4.3.4
8. 08_admin_user_created.png - Bölüm 4.3.4
9. 09_terminal_insert_query.png - Bölüm 4.3.4
10. 10_secure_version_login_attempt.png - Bölüm 5.2.3
11. 11_secure_login_blocked.png - Bölüm 5.2.3
12. 12_terminal_parameterized_query.png - Bölüm 5.2.3
13. 13_secure_union_attempt.png - Bölüm 5.3.2
14. 14_secure_union_blocked.png - Bölüm 5.3.2
15. 15_secure_admin_panel_attempt.png - Bölüm 5.4.2
16. 16_secure_payload_as_string.png - Bölüm 5.4.2
17. 17_comparison_side_by_side.png - Bölüm 6.1

11.3 Terminal Komutları

Uygulamayı Çalıştırma:
# Virtual environment aktif et
source venv/bin/activate

# Güvensiz versiyon
python3 app.py

# Güvenli versiyon (ayrı terminal)
python3 app_secure.py

Veritabanını Sıfırlama:
rm -f restaurant.db restaurant_secure.db
python3 app.py  # Otomatik olarak yeniden oluşturulur

================================================================================
12. RAPOR ONAYI
================================================================================

Bu rapor, Vulnerability and Security dersi kapsamında hazırlanmıştır ve tüm 
testler kontrollü bir ortamda gerçekleştirilmiştir.

Hazırlayan: Ege Koca
Tarih: 2025
Durum: Tamamlandı

Not: Bu rapor, eğitim amaçlı hazırlanmıştır. Gerçek sistemlerde bu tür açıklar 
ciddi güvenlik ihlallerine ve yasal sonuçlara yol açabilir.

================================================================================
SON
================================================================================
